/*****************************************************************/
/** Copyright(C) J. Dayan Rodriguez, 2022, All rights reserved. **/
/*****************************************************************/
//
// This header file contains all the types and forward declarations necessary
// to parse and statically evaluate a translation unit.
//
#ifndef KTTC_HEADER_FILE_PARSER
#define KTTC_HEADER_FILE_PARSER

/**
 * Most of these tokens are directly generated by the lexer, others that require more in depth
 * contextual analysis are not. Nonetheless they are included here for ease of readability and because
 * technically, they are tokens.
 *
 * Some tokens are considered keywords but may not map directly to their enum name, for instance <align_of> maps to '_Alignof'.
 *
 * There will be a comment next to the token specifying which literal it maps and whether the lexer produces this token directly
 * or not.
 *
 * Some tokens are considered part of one or more groups, those have to be in the intersection of both groups.
 * Luckly there's only one case.
 **/

typedef enum cctokentype_kind
{
  cctokentype_invalid = - 1, // <-- for the hash table this means that it wasn't there before.
  /**
   * Group: syntactic operators.
   **/
  cctokentype_end     =   0,

  // ** this is up to the lexer to determine and the parser to interpret **
  cctokentype_endimpl, // '\r\n'
  cctokentype_endexpl, // ';'

  cctokentype_lparen,  // '('
  cctokentype_rparen,  // ')'
  cctokentype_lcurly,  // '{'
  cctokentype_rcurly,  // '}'
  cctokentype_lsquare, // '['
  cctokentype_rsquare, // ']'

  cctokentype_comma, // ','
  cctokentype_colon, // ':'
  cctokentype_space, // ' '

  /**
   * Group: literals.
   **/
  cctokentype_literal_ellipsis,
  cctokentype_literal_comment,
  cctokentype_literal_character,
  cctokentype_literal_string,
  cctokentype_literal_string_format,
  cctokentype_literal_string_unterminated,
  cctokentype_literal_identifier,
  cctokentype_literal_integer,
  cctokentype_literal_float,
  /**
   * Group: msvc attributes.
   *
   *  ** these are reserved keywords **
   **/
  cctokentype_msvc_attr_asm,       // maps to:  __asm
  cctokentype_msvc_attr_based,     // maps to:  __based
  cctokentype_msvc_attr_cdecl,     // maps to:  __cdecl
  cctokentype_msvc_attr_clrcall,   // maps to:  __clrcall
  cctokentype_msvc_attr_fastcall,  // maps to:  __fastcall
  cctokentype_msvc_attr_inline,    // maps to:  __inline
  cctokentype_msvc_attr_stdcall,   // maps to:  __stdcall
  cctokentype_msvc_attr_thiscall,  // maps to:  __thiscall
  cctokentype_msvc_attr_vectorcal, // maps to:  __vectorcal
  /**
   * Group: alignment specifiers
   *
   * ** these are reserved keywords **
   **/
  kttc__algn_spec_0,
  cctokentype_align_of, // maps to: _Alignof
  cctokentype_align_as, // maps to: _Alignas
  kttc__algn_spec_1,
  /**
   * Group: type qualifiers
   *
   * ** these are reserved keywords **
   **/
  cctype_qual_0,
  cctokentype_const,    // maps to: const
  cctokentype_restrict, // maps to: restrict
  cctokentype_volatile, // maps to: volatile
  cctype_qual_1,
  /**
   * Group: function specifiers.
   *
   * ** these are reserved keywords **
   **/
  kttc__func_spec_0,
  cctokentype_inline,
  cctokentype_no_return,
  kttc__func_spec_1,
  /**
   * Group: type specifiers.
   *
   * ** these are reserved keywords **
   **/
  cctype_spec_0,
  cctokentype_signed, // group start
  cctokentype_unsigned,
  cctokentype_msvc_int8,  // __int8
  cctokentype_msvc_int16, // __int16
  cctokentype_msvc_int32, // __int32
  cctokentype_msvc_int64, // __int64
  cctokentype_double,
  cctokentype_float,
  cctokentype_long,
  cctokentype_int,
  cctokentype_short,
  cctokentype_char,
  cctokentype_void,
  cctokentype_bool,     // _Bool
  cctokentype_complex,  // _Complex
  cctokentype_atomic,   // _Atomic
  cctokentype_enum,
  cctokentype_struct,
  /**
   * Group: type specifier & storage class.

   * This is a bit wanly but it makes so that I don't have edge cases.
   **/
  kttc__scls_spec_0,

  cctokentype_typedef,

  cctype_spec_1,
  /*
   * Group: storage class.

   * ** these are reseverd keywords **
   **/
  cctokentype_auto,
  cctokentype_extern,
  cctokentype_register,
  cctokentype_static,
  cctokentype_thread_local, // _Thread_local
  cctokentype_msvc_declspec, // __declspec

  kttc__scls_spec_1,

  /**
   * Group: control statements.

   * ** these are reseverd keywords **
   **/
  cctokentype_if,
  cctokentype_switch,

  cctokentype_else,
  cctokentype_case,
  cctokentype_default,

  cctokentype_for,
  cctokentype_while,
  cctokentype_do,

  cctokentype_goto,
  cctokentype_return,
  cctokentype_break,
  cctokentype_continue,
  /**
   * Group: operators.
   *
   * ** listed from highest precedence groups to lowest **
   **/
  // Group: unary
  //
  // ** these are not generated by the lexer **
  cctokentype_ptr_dereference,
  cctokentype_ptr_address_of,
  cctokentype_bitwise_invert,

  cctokentype_positive, // +
  cctokentype_negative, // -
  //
  cctokentype_negate, // !
  cctokentype_mso, // .
  cctokentype_msp, // ->
  //
  // Group: multiplicative
  cctokentype_mul,
  cctokentype_div,
  cctokentype_mod,

  // Group: additive
  cctokentype_add,
  cctokentype_sub,

  // Group: shift
  cctokentype_bitwise_shl,
  cctokentype_bitwise_shr,

  // Group: relational
  cctokentype_greater_than,
  cctokentype_less_than,

  // Group: equality
  cctokentype_equals,
  cctokentype_not_equals,

  // Group: bit-wise and
  cctokentype_bitwise_and,

  // Group: bit-wise xor
  cctokentype_bitwise_xor,

  // Group: bit-wise or
  cctokentype_bitwise_or,

  // Group: logical and
  cctokentype_logical_and,

  // Group: logical or
  cctokentype_logical_or,

  // Group: conditional
  cctokentype_conditional,

  // Group: assignment
  cctokentype_assign,
  cctokentype_mul_eql,
  cctokentype_div_eql,
  cctokentype_mod_eql,
  cctokentype_add_eql,
  cctokentype_sub_eql,
  cctokentype_bitwise_shl_eql,
  cctokentype_bitwise_shr_eql,
  cctokentype_greater_than_eql,
  cctokentype_less_than_eql,
  cctokentype_bitwise_and_eql,
  cctokentype_bitwise_xor_eql,
  cctokentype_bitwise_or_eql,

  cctokentype_pre_decrement,
  cctokentype_pre_increment,

  cctokentype_pos_decrement,
  cctokentype_pos_increment,

} cctokentype_kind;

typedef enum cctypekind_t
{ cctype_invalid = 0,
  cctype_void,
  cctype_ptr,
  cctype_arr,
  cctype_fun,
  cctype_enu,
  cctype_uni,
  cctype_stu,
  cctype_cls,
  cctype_int64,
  cctype_int32,
  cctype_int16,
  cctype_int8,
  cctype_uint64,
  cctype_uint32,
  cctype_uint16,
  cctype_uint8,
  cctype_float32,
  cctype_float64,

  cctype_struct_spec,
  cctype_enum_specifier,
} cctypekind_t;

typedef enum cctreetype_t
{ cctree_t_invalid = -1,
  cctree_t_unknown = 0,
  cctree_t_iname,
  cctree_t_tname,

  cctree_decl_name,
  cctree_init_decl_name,
  cctree_init_decl,

  cctree_struct_decl_name,
  cctree_struct_decl,
  cctree_struct_spec,

  cctree_t_designator,
  cctree_t_designation,
  cctree_t_parameter_declaration,

  cctree_t_statement,
  cctree_t_compound_statement,

  cctree_t_integer,
  cctree_t_float,
  cctree_t_string,

  cctree_t_top,
  cctree_t_bop,
  cctree_t_uop,
} cctreetype_t;

typedef struct ccloc_t
{ const char *file;
  const char *func;
  const char *clss;
  int row, col;
} ccloc_t;

typedef struct ccentry_t
{ ccentry_t        * nex;
  cctokentype_kind   bit;
  int                off;
  int                len;
  const char       * key;
} ccentry_t;

// Tokens produced by the lexer are very simple, so the parser may modify them after lexical analysis,
// the lexer however, will check for keywords and format strings.
typedef struct cctok_t
{
  cctokentype_kind bit;
#ifdef _DEBUG
  const char *doc;
#endif

  ccloc_t loc;

  unsigned term_impl: 1;
  unsigned term_expl: 1;

  union
  { int        str;
    double     flo;
    ktt_u64_32 uns;
    ktt_i64_32 sig;
  };
} cctok_t;

typedef struct cclex_t
{ const char *doc_max, *doc_min;
  const char *max,     *min; // <-- points to the beginning and end of the token after its been parsed.

  char *buf;

  ktt_u32       tbl_max;
  ktt_u32       tbl_min;
  ccentry_t *tbl;
  ktt_u32       tbl_dbg;

  cctok_t tok;
} cclex_t;

typedef struct ccreader_t
{ cclex_t  lex; // <-- preserve the lexer to have access to all the strings.
  cctok_t *buf; // <-- all the buffered tokens are stored in this dynamic array.
  cctok_t *max;
  cctok_t *min;
  cctok_t *bed;
} ccreader_t;

typedef struct cctype_t
{ cctypekind_t kind;

  struct cctree_t *name;

  int size;
  int align;

  union
  { cctype_t *ret;
    cctype_t *arr;
    cctype_t *ptr;
    cctype_t *modifier_of;
  };

  struct cctree_t *list;

  int bitoff;
  int bitlen;

  unsigned    is_unsigned: 1;
  unsigned    is_static:   1;
  unsigned    is_variadic: 1;
} cctype_t;

typedef struct cctree_t
{
  cctreetype_t kind;

  union
  {
    struct
    { cctree_t  *list; // <-- list of external declarations.
    } translation_unit;

    struct
    { cctree_t  *decl; // <-- declaration or function definition.

      cctree_t  *next; // <-- when part of a translation unit.
    } external_declaration;

    struct
    { cctree_t  *decl;
      cctree_t  *body;
    } function_definition;

    struct
    { cctree_t  *decl_or_expr;
    } statement;

    struct
    { cctree_t  *list; // <-- to be replaced.
    } compound_statement;

    struct
    { cctype_t * type;
      cctok_t  token;
    } constant;


    struct
    { cctok_t   token;
      cctree_t  * expr; // <-- either a const expression or an identifier.

      cctree_t  * next; // <-- part of the designator list.
    } designator;
    struct
    { cctree_t  * list;
      cctree_t  * init;

      cctree_t  * next; // <-- if part of an initializer list.
    } designation;

    struct
    { cctree_t *expr;
      cctree_t *next;
    } init;
    struct
    { cctree_t *decl; // <-- declarator
      cctree_t *next; // <-- when part of the parameter-list
    } parameter_declaration;

    struct
    { cctree_t *name;
    } enum_specifier;

    struct
    { cctype_t *type;
      cctree_t *name;
    } decl_name;

    // Note: decl refers to decl_name
    struct
    { cctree_t *decl;
      cctree_t *expr; // <-- ':' <constant-expression>
    } struct_decl_name;
    struct
    // Note: list refers to an array of struct_decl_name
    { cctype_t *type;
      cctree_t *list;
    } struct_decl;
    struct
    { cctree_t *name; // struct_tagname ...
      cctree_t *list; // struct_decl list
    } struct_spec;

    // Note: decl referst to decl_name
    struct
    { cctree_t *decl;
      cctree_t *init;
    } init_decl_name;
    // Note: list refers to an array of init_decl_name
    struct
    { cctype_t *type;
      cctree_t *list;
    } init_decl;

    struct
    { cctok_t     opr;
      cctree_t  * lhs;
      cctree_t  * mhs;
      cctree_t  * rhs;
    } top;
    struct
    { cctok_t     opr;
      cctree_t  * lhs;
      cctree_t  * rhs;
    } bop;
    struct
    { cctok_t     opr;
      cctree_t  * mhs;
    } uop;
  };
} cctree_t;


// TODO(RJ): make this legit!
#ifndef ccsynerr
#ifdef _DEBUG
# define ccsynerr(tok,cod,fmt, ...) cctraceerr(fmt, __VA_ARGS__), ccbreak()
#else
# define ccsynerr(tok,cod,fmt, ...) cctraceerr(fmt, __VA_ARGS__)
#endif
#endif

#ifndef ccsynwar
# define ccsynwar(tok,cod,fmt, ...) cctracewar(fmt, __VA_ARGS__)
#endif


ccfunc void
cclex_init(cclex_t *l);

ccfunc void
cclex_move(cclex_t *l, size_t len, const char *bed);

ccfunc ktt_i32
cclex_next_token(cclex_t *l);

ccfunc void
cclex_token(cclex_t *l, cctok_t *token);

ccfunc const char *
cclex_tokstr(cclex_t *l, cctok_t *token);

ccfunc void
cclex_uninit(cclex_t *l);

ccfunc cctok_t *
ccpeep(ccreader_t *parser);

ccfunc ktt_i32
ccsee(ccreader_t *parser, cctokentype_kind kind);

ccfunc ktt_i32
ccsee_end(ccreader_t *parser);

ccfunc ktt_i32
kttc__peek_increment(ccreader_t *parser);

ccfunc ktt_i32
kttc__peek_decrement(ccreader_t *parser);

ccfunc cctok_t *
kttc__consume_oper_increment(ccreader_t *parser, cctokentype_kind new_bit);

ccfunc cctok_t *
kttc__consume_oper_decrement(ccreader_t *parser, cctokentype_kind new_bit);

ccfunc cctok_t *
ccgobble(ccreader_t *parser); // <-- use this if you've already peeked.

ccfunc cctok_t *
ccgobble(ccreader_t *parser);

ccfunc cctok_t * // <-- returns nullptr otherwise
cceat(ccreader_t *parser, cctokentype_kind kind);

ccfunc cctok_t * // <-- returns nullptr otherwise
kttc__peek_storage_class(ccreader_t *parser);

ccfunc cctok_t * // <-- returns nullptr otherwise
kttc__peek_type_qualifier(ccreader_t *parser);

ccfunc cctok_t * // <-- returns nullptr otherwise
ccsee_typespec(ccreader_t *parser);

ccfunc cctok_t * // <-- returns nullptr otherwise
kttc__peek_func_specifier(ccreader_t *parser);

ccfunc cctok_t * // <-- returns nullptr otherwise
kttc__peek_alignment_specifier(ccreader_t *parser);

// kttc-read-decl.c
ccfunc cctree_t *
ccread_designator(ccreader_t *parser);

ccfunc cctree_t *
ccread_designator_list(ccreader_t *parser);

ccfunc cctree_t *
ccread_init_designation(ccreader_t *parser);

ccfunc cctree_t *
ccread_initializer_list(ccreader_t *parser);

ccfunc cctree_t *
ccread_initializer(ccreader_t *parser);

ccfunc cctree_t *
ccread_direct_declarator(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_decl_name(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_declarator(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_decl_name_list(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_decl(ccreader_t *parser);

ccfunc cctree_t * // <-- returns null when the base_type is null
ccread_struct_declarator(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_struct_declarator_list(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_struct_declaration(ccreader_t *parser);

ccfunc cctree_t *
ccread_struct_declaration_list(ccreader_t *parser);


ccfunc ktt_i32
ccread_attribute_seq(ccreader_t *parser);

ccfunc cctype_t *
ccread_declaration_specifiers(ccreader_t *parser);

ccfunc cctype_t *
ccread_specifier_qualifier_list(ccreader_t *parser);

ccfunc cctree_t *
ccread_assignment_expr(ccreader_t *parser);

ccfunc cctree_t *
ccread_expression(ccreader_t *parser);

ccfunc cctree_t *
ccread_cast_expr(ccreader_t *parser);

ccfunc cctree_t *
ccread_declname(ccreader_t *parser, cctype_t *base_type);

ccfunc void
cctype_del(cctype_t *type);

ccfunc cctype_t *
cctype_new(cctypekind_t kind);

ccfunc cctype_t *
cctype_clone(cctype_t *type);

ccfunc cctype_t *
cctype_new_ptr(cctype_t *modifier_of);

ccfunc cctype_t *
cctype_new_arr(cctype_t *modifier_of);

ccfunc cctype_t *
cctype_new_fun(cctype_t *modifier_of);

ccfunc void
cctree_del(cctree_t *tree);

ccfunc cctree_t *
cctree_new(cctreetype_t kind);

ccfunc cctree_t *
cctree_new_constant(cctype_t *type, cctok_t *token);

ccfunc cctree_t *
cctree_new_top(cctok_t *token, cctree_t *lhs, cctree_t *mhs, cctree_t *rhs);

ccfunc cctree_t *
cctree_new_bop(cctok_t *token, cctree_t *lhs, cctree_t *rhs);

ccfunc cctree_t *
cctree_new_uop(cctok_t *token, cctree_t *mhs);

ccfunc cctree_t *
cctree_new_designator(cctok_t *token, cctree_t *expr);

ccfunc cctree_t *
cctree_new_designation(cctree_t *list, cctree_t *init);

ccfunc cctree_t *
cctree_new_init_declarator(cctree_t *decl, cctree_t *init);

ccfunc cctree_t *
cctree_new_init_declaration(cctype_t *type, cctree_t *list);

ccfunc cctree_t *
cctree_new_identifier(cctok_t *token);

ccfunc cctree_t *
cctree_new_struct_declarator(cctree_t *decl, cctree_t *expr);

ccfunc cctree_t *
cctree_new_struct_decl(cctype_t *type, cctree_t *list);



// TEMPORARY:
ktt__global cctype_t
  *ctype_flo32  = cctype_new(cctype_float32),
  *ctype_flo64  = cctype_new(cctype_float64),
  *ctype_int64  = cctype_new(cctype_int64),
  *ctype_int32  = cctype_new(cctype_int32),
  *ctype_int16  = cctype_new(cctype_int16),
  *ctype_int8   = cctype_new(cctype_int8),
  *ctype_uint64 = cctype_new(cctype_uint64),
  *ctype_uint32 = cctype_new(cctype_uint32),
  *ctype_uint16 = cctype_new(cctype_uint16),
  *ctype_uint8  = cctype_new(cctype_uint8),
  *ctype_void   = cctype_new(cctype_void);

#endif
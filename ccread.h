/*****************************************************************/
/** Copyright(C) J. Dayan Rodriguez, 2022, All rights reserved. **/
/*****************************************************************/
#ifndef _CCREAD
#define _CCREAD

// Implementation based on the:
// https://learn.microsoft.com/en-us/cpp/c-language/c-language-reference
//

/**
 * Most of these tokens are directly generated by the lexer, others that require more in depth
 * contextual analysis are not. Nonetheless they are included here for ease of readability and because
 * technically, they are tokens.
 *
 * Some tokens are considered keywords but may not map directly to their enum name, for instance <align_of> maps to '_Alignof'.
 *
 * There will be a comment next to the token specifying which literal it maps and whether the lexer produces this token directly
 * or not.
 *
 * Some tokens are considered part of one or more groups, those have to be in the intersection of both groups.
 * Luckly there's only one case.
 **/

typedef enum cctoken_Kkind
{
  cctoken_Kinvalid = - 1, // <-- for the hash table this means that it wasn't there before.
  /**
   * Group: syntactic operators.
   **/
  cctoken_Kend     =   0,

  // ** this is up to the lexer to determine and the parser to interpret **
  cctoken_Kendimpl, // '\r\n'
  cctoken_Kendexpl, // ';'

  cctoken_Klparen,  // '('
  cctoken_Krparen,  // ')'
  cctoken_Klcurly,  // '{'
  cctoken_Krcurly,  // '}'
  cctoken_Klsquare, // '['
  cctoken_Krsquare, // ']'

  cctoken_Kcomma, // ','
  cctoken_Kcolon, // ':'
  cctoken_Kspace, // ' '

  /**
   * Group: literals.
   **/
  cctoken_Kliteral_ellipsis,
  cctoken_Kliteral_comment,
  cctoken_Kliteral_character,
  cctoken_Kliteral_string,
  cctoken_Kliteral_string_format,
  cctoken_Kliteral_string_unterminated,
  cctoken_Kliteral_identifier,
  cctoken_Kliteral_integer,
  cctoken_Kliteral_float,
  /**
   * Group: msvc attributes.
   *
   *  ** these are reserved keywords **
   **/
  cctoken_Kmsvc_attr_asm,       // maps to:  __asm
  cctoken_Kmsvc_attr_based,     // maps to:  __based
  cctoken_Kmsvc_attr_cdecl,     // maps to:  __cdecl
  cctoken_Kmsvc_attr_clrcall,   // maps to:  __clrcall
  cctoken_Kmsvc_attr_fastcall,  // maps to:  __fastcall
  cctoken_Kmsvc_attr_inline,    // maps to:  __inline
  cctoken_Kmsvc_attr_stdcall,   // maps to:  __stdcall
  cctoken_Kmsvc_attr_thiscall,  // maps to:  __thiscall
  cctoken_Kmsvc_attr_vectorcal, // maps to:  __vectorcal
  /**
   * Group: alignment specifiers
   *
   * ** these are reserved keywords **
   **/
  kttc__algn_spec_0,
  cctoken_Kalign_of, // maps to: _Alignof
  cctoken_Kalign_as, // maps to: _Alignas
  kttc__algn_spec_1,
  /**
   * Group: type qualifiers
   *
   * ** these are reserved keywords **
   **/
  cctype_qual_0,
  cctoken_Kconst,    // maps to: const
  cctoken_Krestrict, // maps to: restrict
  cctoken_Kvolatile, // maps to: volatile
  cctype_qual_1,
  /**
   * Group: function specifiers.
   *
   * ** these are reserved keywords **
   **/
  kttc__func_spec_0,
  cctoken_Kinline,
  cctoken_Kno_return,
  kttc__func_spec_1,
  /**
   * Group: type specifiers.
   *
   * ** these are reserved keywords **
   **/
  cctype_spec_0,
  cctoken_Ksigned, // group start
  cctoken_Kunsigned,
  cctoken_Kmsvc_int8,  // __int8
  cctoken_Kmsvc_int16, // __int16
  cctoken_Kmsvc_int32, // __int32
  cctoken_Kmsvc_int64, // __int64
  cctoken_Kdouble,
  cctoken_Kfloat,
  cctoken_Klong,
  cctoken_Kint,
  cctoken_Kshort,
  cctoken_Kchar,
  cctoken_Kvoid,
  cctoken_Kbool,     // _Bool
  cctoken_Kcomplex,  // _Complex
  cctoken_Katomic,   // _Atomic
  cctoken_Kenum,
  cctoken_Kstruct,
  /**
   * Group: type specifier & storage class.

   * This is a bit wanly but it makes so that I don't have edge cases.
   **/
  kttc__scls_spec_0,

  cctoken_Ktypedef,

  cctype_spec_1,
  /*
   * Group: storage class.

   * ** these are reseverd keywords **
   **/
  cctoken_Kauto,
  cctoken_Kextern,
  cctoken_Kregister,
  cctoken_Kstatic,
  cctoken_Kthread_local, // _Thread_local
  cctoken_Kmsvc_declspec, // __declspec

  kttc__scls_spec_1,

  /**
   * Group: control statements.

   * ** these are reseverd keywords **
   **/
  cctoken_Kif,
  cctoken_Kswitch,

  cctoken_Kelse,
  cctoken_Kcase,
  cctoken_Kdefault,

  cctoken_Kfor,
  cctoken_Kwhile,
  cctoken_Kdo,

  cctoken_Kgoto,
  cctoken_Kreturn,
  cctoken_Kbreak,
  cctoken_Kcontinue,
  /**
   * Group: operators.
   *
   * ** listed from highest precedence groups to lowest **
   **/
  // Group: unary
  //
  // ** these are not generated by the lexer **
  cctoken_Kptr_dereference,
  cctoken_Kptr_address_of,
  cctoken_Kbitwise_invert,

  cctoken_Kpositive, // +
  cctoken_Knegative, // -
  //
  cctoken_Knegate, // !
  cctoken_Kmso, // .
  cctoken_Kmsp, // ->
  //
  // Group: multiplicative
  cctoken_Kmul,
  cctoken_Kdiv,
  cctoken_Kmod,

  // Group: additive
  cctoken_Kadd,
  cctoken_Ksub,

  // Group: shift
  cctoken_Kbitwise_shl,
  cctoken_Kbitwise_shr,

  // Group: relational
  cctoken_Kgreater_than,
  cctoken_Kless_than,

  // Group: equality
  cctoken_Kequals,
  cctoken_Knot_equals,

  // Group: bit-wise and
  cctoken_Kbitwise_and,

  // Group: bit-wise xor
  cctoken_Kbitwise_xor,

  // Group: bit-wise or
  cctoken_Kbitwise_or,

  // Group: logical and
  cctoken_Klogical_and,

  // Group: logical or
  cctoken_Klogical_or,

  // Group: conditional
  cctoken_Kconditional,

  // Group: assignment
  cctoken_Kassign,
  cctoken_Kmul_eql,
  cctoken_Kdiv_eql,
  cctoken_Kmod_eql,
  cctoken_Kadd_eql,
  cctoken_Ksub_eql,
  cctoken_Kbitwise_shl_eql,
  cctoken_Kbitwise_shr_eql,
  cctoken_Kgreater_than_eql,
  cctoken_Kless_than_eql,
  cctoken_Kbitwise_and_eql,
  cctoken_Kbitwise_xor_eql,
  cctoken_Kbitwise_or_eql,

  cctoken_Kpre_decrement,
  cctoken_Kpre_increment,

  cctoken_Kpos_decrement,
  cctoken_Kpos_increment,

} cctoken_Kkind;

typedef enum cctypekind_t
{ cctype_invalid = 0,
  cctype_void,
  cctype_ptr,
  cctype_arr,
  cctype_Kfunc,
  cctype_enu,
  cctype_uni,
  cctype_stu,
  cctype_cls,
  cctype_int64,
  cctype_int32,
  cctype_int16,
  cctype_int8,
  cctype_uint64,
  cctype_uint32,
  cctype_uint16,
  cctype_uint8,
  cctype_float32,
  cctype_float64,

  cctype_struct_spec,
  cctype_enum_specifier,
} cctypekind_t;

typedef enum cctreetype_t
{ cctree_t_invalid = -1,
  cctree_t_unknown = 0,
  cctree_t_tname,

  cctree_Kidentifier,

  cctree_Klabel_statement,
  cctree_Kreturn_statement,
  cctree_Kgoto_statement,
  cctree_Kconditional_statement,
  cctree_Kwhile_statement,

  cctree_Kdecl_name,
  cctree_Kdecl,

  cctree_Kstruct_spec,

  cctree_t_designator,
  cctree_t_designation,
  cctree_t_parameter_declaration,

  cctree_Kmixed_statement,

// Todo: remove
  cctree_Kint,
  cctree_t_float,
  cctree_t_string,

  cctree_t_top,
  cctree_Kbinary,
  cctree_t_uop,
} cctreetype_t;

typedef struct ccloc_t
{ const char *file;
  const char *func;
  const char *clss;
  int row, col;
} ccloc_t;

typedef struct ccentry_t
{ ccentry_t   * nex;
  char        * key;
  int           len;
  int           bit;
} ccentry_t;

// Tokens produced by the lexer are very simple, so the parser may modify them after lexical analysis,
// the lexer however, will check for keywords and format strings.
typedef struct cctoken_t
{
  cctoken_Kkind bit;

  union
  { unsigned long long int sig;
    unsigned long long int uns;
    double                 flo;
    ccstr_t                str;
  };

#ifdef _DEBUG
  const char *doc;
#endif

  ccloc_t loc;

  unsigned term_impl: 1;
  unsigned term_expl: 1;
} cctoken_t;

typedef struct cclex_t
{ const char *doc_max, *doc_min;
  const char *max,     *min; // <-- points to the beginning and end of the token after its been parsed.

  ktt_u32    tbl_max;
  ktt_u32    tbl_min;
  ccentry_t *tbl;
  ktt_u32    tbl_dbg;
  cctoken_t  tok;
} cclex_t;

typedef struct ccreader_t
{
  cclex_t    lex;
  cctoken_t *buf;
  cctoken_t *max;
  cctoken_t *min;
  cctoken_t *bed;
} ccreader_t;

typedef struct cctype_t
{ cctypekind_t kind;

  const char *name;

  int size;
  int align;

  union
  { cctype_t *ret;
    cctype_t *arr;
    cctype_t *ptr;
    cctype_t *modifier_of;
  };

  struct cctree_t *list;

  int bitoff;
  int bitlen;

  unsigned    is_unsigned: 1;
  unsigned    is_static:   1;
  unsigned    is_variadic: 1;
} cctype_t;

// Todo: have a location ready ...
// Note: freaking hate this ...
typedef struct cctree_t
{
  cctreetype_t kind;
  // for statement, while statement, do while statement, conditional statement ...
  cctree_t *init_tree;
  cctree_t *cond_tree;
  cctree_t *then_tree;
  cctree_t *else_tree;
  // return statement
  cctree_t *expr_tree;

  cctype_t *decl_name_type;
  ccstr_t   decl_name_iden;
  // init_decl_name_initializer:
  cctree_t *decl_name_init;
  // struct_decl_name_constant_expression:
  cctree_t *decl_name_expr;

  // declartion_base_type:
  cctype_t *decl_type;
  cctree_t *decl_name; // Note: list

  cctree_t *decl_list;

  // func_definition, struct_definition, enum_definition ...
  cctree_t *body_tree;
  cctree_t *name;


  union
  { struct
    { cctype_t * type;
      cctoken_t  token;
    } constant;
    struct
    { cctoken_t   token;
      cctree_t  * expr; // <-- either a const expression or an identifier.
      cctree_t  * next; // <-- part of the designator list.
    } designator;
    struct
    { cctree_t  * list;
      cctree_t  * init;

      cctree_t  * next; // <-- if part of an initializer list.
    } designation;
    struct
    { cctree_t *decl; // <-- declarator
      cctree_t *next; // <-- when part of the parameter-list
    } parameter_declaration;
    struct
    { ccstr_t   name;
      cctree_t *list;
    } label_statement;
    struct
    { ccstr_t   name;
    } goto_statement;
    struct
    { cctree_t *stat;
      cctree_t *decl;
    } mix_statement;




    struct
    { cctoken_t   opr;
      cctree_t  * lhs;
      cctree_t  * mhs;
      cctree_t  * rhs;
    } top;
    struct
    { cctoken_t   opr;
      cctree_t  * lhs;
      cctree_t  * rhs;
    } binary;
    struct
    { cctoken_t   opr;
      cctree_t  * mhs;
    } uop;
  };
} cctree_t;


// TODO(RJ): make this legit!
#ifndef ccsynerr
#ifdef _DEBUG
# define ccsynerr(tok,cod,fmt, ...) cctraceerr(fmt, __VA_ARGS__), ccbreak()
#else
# define ccsynerr(tok,cod,fmt, ...) cctraceerr(fmt, __VA_ARGS__)
#endif
#endif
#ifndef ccsynwar
# define ccsynwar(tok,cod,fmt, ...) cctracewar(fmt, __VA_ARGS__)
#endif


ccfunc ccstr_t
cctree_idenname(cctree_t *name)
{
  return name?name->constant.token.str:0;
}

ccfunc void
cclex_init(cclex_t *l);

ccfunc void
cclex_move(cclex_t *l, size_t len, const char *bed);

ccfunc ktt_i32
cclex_next_token(cclex_t *l);

ccfunc void
cclex_token(cclex_t *l, cctoken_t *token);

ccfunc void
cclex_uninit(cclex_t *l);

ccfunc cctoken_t *
ccpeep(ccreader_t *parser);

ccfunc ktt_i32
ccsee(ccreader_t *parser, cctoken_Kkind kind);

ccfunc ktt_i32
ccsee_end(ccreader_t *parser);

ccfunc ktt_i32
kttc__peek_increment(ccreader_t *parser);

ccfunc ktt_i32
kttc__peek_decrement(ccreader_t *parser);

ccfunc cctoken_t *
kttc__consume_oper_increment(ccreader_t *parser, cctoken_Kkind new_bit);

ccfunc cctoken_t *
kttc__consume_oper_decrement(ccreader_t *parser, cctoken_Kkind new_bit);

ccfunc cctoken_t *
ccgobble(ccreader_t *parser); // <-- use this if you've already peeked.

ccfunc cctoken_t *
ccgobble(ccreader_t *parser);

ccfunc cctoken_t * // <-- returns nullptr otherwise
cceat(ccreader_t *parser, cctoken_Kkind kind);

ccfunc cctoken_t * // <-- returns nullptr otherwise
kttc__peek_storage_class(ccreader_t *parser);

ccfunc cctoken_t * // <-- returns nullptr otherwise
kttc__peek_type_qualifier(ccreader_t *parser);

ccfunc cctoken_t * // <-- returns nullptr otherwise
ccsee_typespec(ccreader_t *parser);

ccfunc cctoken_t * // <-- returns nullptr otherwise
kttc__peek_func_specifier(ccreader_t *parser);

ccfunc cctoken_t * // <-- returns nullptr otherwise
kttc__peek_alignment_specifier(ccreader_t *parser);

// kttc-read-decl.c
ccfunc cctree_t *
ccread_designator(ccreader_t *parser);

ccfunc cctree_t *
ccread_designator_list(ccreader_t *parser);

ccfunc cctree_t *
ccread_init_designation(ccreader_t *parser);

ccfunc cctree_t *
ccread_initializer_list(ccreader_t *parser);

ccfunc cctree_t *
ccread_initializer(ccreader_t *parser);

ccfunc cctree_t *
ccread_direct_declarator(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_decl_name(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_declarator(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_decl_name_list(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_decl(ccreader_t *parser);

ccfunc cctree_t * // <-- returns null when the base_type is null
ccread_struct_declarator(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_struct_declarator_list(ccreader_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_struct_declaration(ccreader_t *parser);

ccfunc cctree_t *
ccread_struct_declaration_list(ccreader_t *parser);


ccfunc ktt_i32
ccread_attribute_seq(ccreader_t *parser);

ccfunc cctype_t *
ccread_declaration_specifiers(ccreader_t *parser);

ccfunc cctype_t *
ccread_specifier_qualifier_list(ccreader_t *parser);

ccfunc cctree_t *
ccread_assignment_expr(ccreader_t *parser);

ccfunc cctree_t *
ccread_expression(ccreader_t *parser);

ccfunc cctree_t *
ccread_cast_expr(ccreader_t *parser);

ccfunc cctree_t *
ccread_declname(ccreader_t *parser, cctype_t *base_type);

ccfunc void
cctype_del(cctype_t *type);

ccfunc cctype_t *
cctype_new(cctypekind_t kind, const char *name);

ccfunc cctype_t *
cctype_clone(cctype_t *type);

ccfunc cctype_t *
cctype_new_ptr(cctype_t *modifier_of);

ccfunc cctype_t *
cctype_new_arr(cctype_t *modifier_of);

ccfunc cctype_t *
cctype_new_fun(cctype_t *modifier_of);

ccfunc void
cctree_del(cctree_t *tree);

ccfunc cctree_t *
cctree_new(cctreetype_t kind);

ccfunc cctree_t *
cctree_new_constant(cctype_t *type, cctoken_t *token);

ccfunc cctree_t *
cctree_new_top(cctoken_t *token, cctree_t *lhs, cctree_t *mhs, cctree_t *rhs);

ccfunc cctree_t *
cctree_binary(cctoken_t *token, cctree_t *lhs, cctree_t *rhs);

ccfunc cctree_t *
cctree_new_uop(cctoken_t *token, cctree_t *mhs);

ccfunc cctree_t *
cctree_new_designator(cctoken_t *token, cctree_t *expr);

ccfunc cctree_t *
cctree_new_designation(cctree_t *list, cctree_t *init);

ccfunc cctree_t *
cctree_new_init_declarator(cctree_t *decl, cctree_t *init);

ccfunc cctree_t *
cctree_new_init_declaration(cctype_t *type, cctree_t *list);

ccfunc cctree_t *
cctree_new_identifier(cctoken_t *token);



// TEMPORARY:
ccglobal cctype_t
  *ctype_flo32  = cctype_new(cctype_float32,"keitt::f32"),
  *ctype_flo64  = cctype_new(cctype_float64,"keitt::f64"),
  *ctype_int64  = cctype_new(cctype_int64,"keitt::i64"),
  *ctype_int32  = cctype_new(cctype_int32,"keitt::i32"),
  *ctype_int16  = cctype_new(cctype_int16,"keitt::i16"),
  *ctype_int8   = cctype_new(cctype_int8,"keitt::i8"),
  *ctype_uint64 = cctype_new(cctype_uint64,"keitt::u64"),
  *ctype_uint32 = cctype_new(cctype_uint32,"keitt::u32"),
  *ctype_uint16 = cctype_new(cctype_uint16,"keitt::u16"),
  *ctype_uint8  = cctype_new(cctype_uint8,"keitt::u8"),
  *ctype_void   = cctype_new(cctype_void,"keitt::void");




ccfunc void
ccreader_init(ccreader_t *parser)
{ memset(parser, 0, sizeof(*parser));
  cclex_init(& parser->lex);
  parser->bed = 0;
  parser->min = 0;
  parser->max = 0;
}

ccfunc void
ccreader_uninit(ccreader_t *parser)
{ cclex_uninit(& parser->lex); // <-- free all the string memory.
  ccarrdel(parser->buf); // <-- free all the buffered tokens.
}

ccfunc void
ccread_all_tokens(ccreader_t *parser);

// Todo: reset the token array ...
ccfunc void
ccreader_move(ccreader_t *parser, size_t len, const char *min)
{
	cclex_move(& parser->lex, len, min);
  ccread_all_tokens(parser);

  parser->bed = 0;
  parser->min = parser->buf;
  parser->max = parser->buf + ccarrlen(parser->buf);
}

ccfunc void
ccreader_file(ccreader_t *reader, const char *name)
{
  unsigned long int size;
  void *file=ccopenfile(name);
  void *data=ccpullfile(file,0,&(size=0));
  ccclosefile(file);

  ccreader_move(reader,size,(char*)data);

  // Todo:
  // ccfree(data);
}

ccfunc void
ccread_all_tokens(ccreader_t *parser)
{ while(cclex_next_token(& parser->lex))
  {
    cctoken_t *token=ccarradd(parser->buf,1);
    cclex_token(& parser->lex,token);
  }
}

ccfunc cctoken_t *
kttc__peek_ahead(ccreader_t *parser, ktt_i32 offset)
{ if((parser->min + offset < parser->max))
  { return parser->min + offset;
  }
  // TODO(RJ): this should point to a valid location in a file?
  static cctoken_t end_tok = { cctoken_Kend }; // <-- hopefully no-one modifies this.
  return & end_tok;
}

ccfunc cctoken_t *
ccpeep(ccreader_t *parser)
{ return kttc__peek_ahead(parser, 0);
}

ccfunc ktt_i32
ccsee(ccreader_t *parser, cctoken_Kkind kind)
{ return ccpeep(parser)->bit == kind;
}

ccfunc ktt_i32
ccsee_end(ccreader_t *parser)
{ return ccsee(parser, cctoken_Kend);
}

ccfunc ktt_i32
kttc__peek_oper_increment(ccreader_t *parser)
{
  cctoken_t *tok0 = kttc__peek_ahead(parser, 0);
  cctoken_t *tok1 = kttc__peek_ahead(parser, 1);
  return (tok0->sig == cctoken_Kadd) && (tok1->sig == cctoken_Kadd);
}

ccfunc ktt_i32
kttc__peek_oper_decrement(ccreader_t *parser)
{
  cctoken_t *tok0 = kttc__peek_ahead(parser, 0);
  cctoken_t *tok1 = kttc__peek_ahead(parser, 1);
  return (tok0->sig == cctoken_Ksub) &&  (tok1->sig == cctoken_Ksub);
}

ccfunc cctoken_t *
kttc__consume_oper_increment(ccreader_t *parser, cctoken_Kkind new_sig)
{
  if(kttc__peek_oper_increment(parser))
  { cctoken_t *tok = ccgobble(parser);
    tok->sig = new_sig;
    ccgobble(parser);
    return tok;
  }

  return ccnil;
}

ccfunc cctoken_t *
kttc__consume_oper_decrement(ccreader_t *parser, cctoken_Kkind new_sig)
{
  if(kttc__peek_oper_decrement(parser))
  { cctoken_t *tok = ccgobble(parser);
    tok->sig = new_sig;
    ccgobble(parser);
    return tok;
  }

  return ccnil;
}

ccfunc cctoken_t *
kttc__peek_alignment_specifier(ccreader_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > kttc__algn_spec_0 &&
     token->bit < kttc__algn_spec_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
kttc__peek_type_qualifier(ccreader_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > cctype_qual_0 &&
     token->bit < cctype_qual_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
ccsee_typespec(ccreader_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > cctype_spec_0 &&
     token->bit < cctype_spec_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
kttc__peek_storage_class(ccreader_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > kttc__scls_spec_0 &&
     token->bit < kttc__scls_spec_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
kttc__peek_func_specifier(ccreader_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > kttc__func_spec_0 &&
     token->bit < kttc__func_spec_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
ccgobble(ccreader_t *reader)
{ if((reader->min<reader->max)) return reader->bed = reader->min ++;
  return ccpeep(reader); // <-- use peek here to return special end token.
}

// NOTE(RJ): gotta be careful with how you inline this in a function call, order of execution my not be what you'd
// expect, especially if one of the arguments is recursive.
ccfunc cctoken_t *
cceat(ccreader_t *parser, cctoken_Kkind kind)
{ if(ccsee(parser,kind)) return ccgobble(parser);
  return 0;
}


ccfunc cctype_t *
cctype_new(cctypekind_t kind, const char *name)
{ cctype_t *result=(cctype_t *)ccmalloc(sizeof(cctype_t));
  memset(result,0,sizeof(*result));

  result->kind=kind;
  result->name=name;
  return result;
}

ccfunc cctree_t *
cctree_new(cctreetype_t kind)
{ cctree_t *result = (cctree_t *) ccmalloc(sizeof(cctree_t));
  memset(result, 0, sizeof(*result));
  result->kind = kind;
  return result;
}

ccfunc void
cctype_del(cctype_t *type)
{ ccfree(type);
}

ccfunc void
cctree_del(cctree_t *tree)
{ ccfree(tree);
}

ccfunc cctype_t *
cctype_clone(cctype_t *type)
{ cctype_t *result=cctype_new(type->kind,0);
  *result=*type;
  return result;
}

ccfunc cctype_t *
cctype_new_ptr(cctype_t *modifier_of)
{ cctype_t *type = cctype_new(cctype_ptr,"ptr");
  type->modifier_of = modifier_of;
  return type;
}

ccfunc cctype_t *
cctype_new_arr(cctype_t *modifier_of)
{ cctype_t *type = cctype_new(cctype_arr,"arr");
  type->modifier_of = modifier_of;
  return type;
}

ccfunc cctype_t *
cctype_new_fun(cctype_t *modifier_of)
{ cctype_t *type = cctype_new(cctype_Kfunc,"fun");
  type->modifier_of = modifier_of;
  return type;
}

ccfunc cctype_t *
cctype_new_struct_spec(cctree_t *list, cctree_t *name)
{ ccassert(list!=0);
  cctype_t *type=cctype_new(cctype_struct_spec,cctree_idenname(name));
  type->list=list;
  return type;
}

ccfunc cctree_t *
cctree_decl_name(cctype_t *type, cctree_t *name, cctree_t *expr, cctree_t *init)
{ cctree_t *tree = cctree_new(cctree_Kdecl_name);
  tree->decl_name_type=type;
  tree->decl_name_iden=cctree_idenname(name);
  tree->decl_name_expr=expr;
  tree->decl_name_init=init;
  return tree;
}


ccfunc cctree_t *
cctree_decl(cctype_t *type, cctree_t *list)
{ cctree_t *tree = cctree_new(cctree_Kdecl);
  tree->decl_type=type;
  tree->decl_name=list;
  return tree;
}

ccfunc cctree_t *
cctree_new_designator(cctoken_t *token, cctree_t *expr)
{ cctree_t *tree = cctree_new(cctree_t_designator);
  tree->designator.token = * token;
  tree->designator.expr  = expr;
  return tree;
}

ccfunc cctree_t *
cctree_new_constant(cctype_t *type, cctoken_t *token)
{ cctree_t *result = cctree_new(cctree_Kint);
  result->constant.type  = type;
  result->constant.token = *token;
  return result;
}

ccfunc cctree_t *
cctree_new_top(cctoken_t *token, cctree_t *lhs, cctree_t *mhs, cctree_t *rhs)
{ cctree_t *result = cctree_new(cctree_Kbinary);
  result->top.opr = * token;
  result->top.lhs = lhs;
  result->top.mhs = mhs;
  result->top.rhs = rhs;
  return result;
}

ccfunc cctree_t *
cctree_binary(cctoken_t *token, cctree_t *lhs, cctree_t *rhs)
{ cctree_t *result = cctree_new(cctree_Kbinary);
  result->binary.opr = * token;
  result->binary.lhs = lhs;
  result->binary.rhs = rhs;
  return result;
}

ccfunc cctree_t *
cctree_new_uop(cctoken_t *token, cctree_t *mhs)
{ cctree_t *result = cctree_new(cctree_t_uop);
  result->uop.opr = * token;
  result->uop.mhs = mhs;
  return result;
}


ccfunc cctree_t *
cctree_new_identifier(cctoken_t *token)
{ // Make sure we return null here, not just for safety but because other functions
  // depend on it for convenience.
  if(token)
  {
    cctree_t *tree = cctree_new(cctree_Kidentifier);
    tree->constant.token = * token;
    return tree;
  }
  return ccnil;
}

#if 0
ccfunc cctree_t *
cctree_new_struct_decl_name(cctree_t *decl, cctree_t *expr)
{ ccassert(decl!=0);
  cctree_t *tree = cctree_new(cctree_Kstruct_decl_name);
  tree->struct_decl_name.decl = decl;
  tree->struct_decl_name.expr = expr;
  return tree;
}
ccfunc cctree_t *
cctree_new_struct_decl(cctype_t *type, cctree_t *list)
{ ccassert(type!=0);
  ccassert(list!=0);
  cctree_t *tree = cctree_new(cctree_Kstruct_decl);
  tree->struct_decl.type = type;
  tree->struct_decl.list = list;
  return tree;
}
#endif

ccfunc cctree_t *
cctree_new_designation(cctree_t *list, cctree_t *init)
{ // Make sure we return null here, not just for safety but because other functions
  // depend on it for convenience.
  if(list)
  {
    cctree_t *tree = cctree_new(cctree_t_designation);
    tree->designation.list = list;
    tree->designation.init = init;
    return tree;
  }
  return ccnil;
}

ccfunc cctree_t *
kttc__make_parameter_declaration(cctree_t *decl)
{
  if(decl)
  {
    cctree_t *tree = cctree_new(cctree_t_parameter_declaration);
    tree->parameter_declaration.decl = decl;
    return tree;
  }
  return ccnil;
}

#endif
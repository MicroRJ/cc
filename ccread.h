/*****************************************************************/
/** Copyright(C) J. Dayan Rodriguez, 2022, All rights reserved. **/
/*****************************************************************/
#ifndef _CCREAD
#define _CCREAD

// Implementation based on the:
// https://learn.microsoft.com/en-us/cpp/c-language/c-language-reference
//

typedef enum cctoken_k
{
  cctoken_Kinvalid = - 1, // <-- for the hash table this means that it wasn't there before.
  /**
   * Group: syntactic operators.
   **/
  cctoken_Kend     =   0,

  // ** this is up to the lexer to determine and the parser to interpret **
  cctoken_Kendimpl, // '\r\n'
  cctoken_Kendexpl, // ';'

  cctoken_Klparen,  // '('
  cctoken_Krparen,  // ')'
  cctoken_Klcurly,  // '{'
  cctoken_Krcurly,  // '}'
  cctoken_Klsquare, // '['
  cctoken_Krsquare, // ']'

  cctoken_Kcomma, // ','
  cctoken_Kcolon, // ':'
  cctoken_Kspace, // ' '

  /**
   * Group: literals.
   **/
  cctoken_Kliteral_ellipsis,
  cctoken_Kliteral_comment,
  cctoken_Kliteral_character,
  cctoken_Kliteral_string,
  cctoken_Kliteral_string_format,
  cctoken_Kliteral_string_unterminated,
  cctoken_Kliteral_identifier,
  cctoken_Kliteral_integer,
  cctoken_Kliteral_float,
  /**
   * Group: msvc attributes.
   *
   *  ** these are reserved keywords **
   **/
  cctoken_Kmsvc_attr_asm,       // maps to:  __asm
  cctoken_Kmsvc_attr_based,     // maps to:  __based
  cctoken_Kmsvc_attr_cdecl,     // maps to:  __cdecl
  cctoken_Kmsvc_attr_clrcall,   // maps to:  __clrcall
  cctoken_Kmsvc_attr_fastcall,  // maps to:  __fastcall
  cctoken_Kmsvc_attr_inline,    // maps to:  __inline
  cctoken_Kmsvc_attr_stdcall,   // maps to:  __stdcall
  cctoken_Kmsvc_attr_thiscall,  // maps to:  __thiscall
  cctoken_Kmsvc_attr_vectorcal, // maps to:  __vectorcal
  /**
   * Group: alignment specifiers
   *
   * ** these are reserved keywords **
   **/
  kttc__algn_spec_0,
  cctoken_Kalign_of, // maps to: _Alignof
  cctoken_Kalign_as, // maps to: _Alignas
  kttc__algn_spec_1,
  /**
   * Group: type qualifiers
   *
   * ** these are reserved keywords **
   **/
  cctype_qual_0,
  cctoken_Kconst,    // maps to: const
  cctoken_Krestrict, // maps to: restrict
  cctoken_Kvolatile, // maps to: volatile
  cctype_qual_1,
  /**
   * Group: function specifiers.
   *
   * ** these are reserved keywords **
   **/
  kttc__func_spec_0,
  cctoken_Kinline,
  cctoken_Kno_return,
  kttc__func_spec_1,
  /**
   * Group: type specifiers.
   *
   * ** these are reserved keywords **
   **/
  cctype_spec_0,
  cctoken_Ksigned, // group start
  cctoken_Kunsigned,
  cctoken_Kmsvc_int8,  // __int8
  cctoken_Kmsvc_int16, // __int16
  cctoken_Kmsvc_int32, // __int32
  cctoken_Kmsvc_int64, // __int64
  cctoken_Kdouble,
  cctoken_Kfloat,
  cctoken_Klong,
  cctoken_Kint,
  cctoken_Kshort,
  cctoken_Kchar,
  cctoken_Kvoid,
  cctoken_Kbool,     // _Bool
  cctoken_Kcomplex,  // _Complex
  cctoken_Katomic,   // _Atomic
  cctoken_Kenum,
  cctoken_Kstruct,
  /**
   * Group: type specifier & storage class.

   * This is a bit wanly but it makes so that I don't have edge cases.
   **/
  kttc__scls_spec_0,

  cctoken_Ktypedef,

  cctype_spec_1,
  /*
   * Group: storage class.

   * ** these are reseverd keywords **
   **/
  cctoken_Kauto,
  cctoken_Kextern,
  cctoken_Kregister,
  cctoken_Kstatic,
  cctoken_Kthread_local, // _Thread_local
  cctoken_Kmsvc_declspec, // __declspec

  kttc__scls_spec_1,

  /**
   * Group: control statements.

   * ** these are reseverd keywords **
   **/
  cctoken_Kif,
  cctoken_Kswitch,

  cctoken_Kelse,
  cctoken_Kcase,
  cctoken_Kdefault,

  cctoken_Kfor,
  cctoken_Kwhile,
  cctoken_Kdo,

  cctoken_Kgoto,
  cctoken_Kreturn,
  cctoken_Kbreak,
  cctoken_Kcontinue,
  /**
   * Group: operators.
   *
   * ** listed from highest precedence groups to lowest **
   **/
  // Group: unary
  //
  // ** these are not generated by the lexer **
  cctoken_Kptr_dereference,
  cctoken_Kptr_address_of,
  cctoken_Kbitwise_invert,

  cctoken_Kpositive, // +
  cctoken_Knegative, // -
  //
  cctoken_Knegate, // !
  cctoken_Kmso, // .
  cctoken_Kmsp, // ->
  //
  // Group: multiplicative
  cctoken_Kmul,
  cctoken_Kdiv,
  cctoken_Kmod,

  // Group: additive
  cctoken_Kadd,
  cctoken_Ksub,

  // Group: shift
  cctoken_Kbitwise_shl,
  cctoken_Kbitwise_shr,

  // Group: relational
  cctoken_Kgreater_than,
  cctoken_Kless_than,

  // Group: equality
  cctoken_Kequals,
  cctoken_Knot_equals,

  // Group: bit-wise and
  cctoken_Kbitwise_and,

  // Group: bit-wise xor
  cctoken_Kbitwise_xor,

  // Group: bit-wise or
  cctoken_Kbitwise_or,

  // Group: logical and
  cctoken_Klogical_and,

  // Group: logical or
  cctoken_Klogical_or,

  // Group: conditional
  cctoken_Kconditional,

  // Group: assignment
  cctoken_kASSIGN,
  cctoken_Kmul_eql,
  cctoken_Kdiv_eql,
  cctoken_Kmod_eql,
  cctoken_Kadd_eql,
  cctoken_Ksub_eql,
  cctoken_Kbitwise_shl_eql,
  cctoken_Kbitwise_shr_eql,
  cctoken_Kgreater_than_eql,
  cctoken_Kless_than_eql,
  cctoken_Kbitwise_and_eql,
  cctoken_Kbitwise_xor_eql,
  cctoken_Kbitwise_or_eql,

  cctoken_Kpre_decrement,
  cctoken_Kpre_increment,

  cctoken_Kpos_decrement,
  cctoken_Kpos_increment,

} cctoken_k;

typedef enum cctypekind_t
{ cctype_invalid = 0,
  cctype_void,
  cctype_ptr,
  cctype_arr,
  cctype_Kfunc,
  cctype_enu,
  cctype_uni,
  cctype_stu,
  cctype_cls,
  cctype_int64,
  cctype_int32,
  cctype_int16,
  cctype_int8,
  cctype_uint64,
  cctype_uint32,
  cctype_uint16,
  cctype_uint8,
  cctype_float32,
  cctype_float64,

  cctype_struct_spec,
  cctype_enum_specifier,
} cctypekind_t;

typedef enum cctreetype_t
{ cctree_t_invalid = -1,
  cctree_t_unknown = 0,
  cctree_t_tname,

  cctree_kIDENTIFIER,

  cctree_kLABEL,
  cctree_kRETRN,
  cctree_Kgoto_statement,
  cctree_Kconditional_statement,
  cctree_Kwhile_statement,

  cctree_Kdecl_name,
  cctree_kDECL,

  cctree_Kstruct_spec,

  cctree_t_designator,
  cctree_t_designation,

  cctree_kBLOCK,

// Todo: remove
  cctree_kINTEGER,
  cctree_t_float,
  cctree_t_string,

  cctree_t_top,
  cctree_kBINARY,
  cctree_t_uop,


  cctree_Kparen_expr,
  cctree_Kcall_expr,
} cctreetype_t;

typedef union ccclassic_t
{
  cci64 as_i64;
  cci32 as_i32;
  cci16 as_i16;
	cci8  as_i8;

	ccu64 as_u64;
  ccu32 as_u32;
  ccu16 as_u16;
	ccu8  as_u8;
} ccclassic_t;

typedef struct ccloc_t
{ const char *file;
  const char *func;
  const char *clss;
  int row, col;
} ccloc_t;

typedef struct ccentry_t
{ ccentry_t   * nex;
  char        * key;
  int           len;
  int           bit;
} ccentry_t;

// Tokens produced by the lexer are very simple, so the parser may modify them after lexical analysis,
// the lexer however, will check for keywords and format strings.
typedef struct cctoken_t
{
  cctoken_k bit;

  union
  { unsigned long long int sig;
    unsigned long long int uns;
    double                 flo;
    ccstr_t                str;
  };

#ifdef _DEBUG
  const char *doc;
#endif

  ccloc_t loc;

  unsigned term_impl: 1;
  unsigned term_expl: 1;
} cctoken_t;

typedef struct cclex_t
{ const char *doc_max, *doc_min;
  const char *max,     *min; // <-- points to the beginning and end of the token after its been parsed.

  ktt_u32    tbl_max;
  ktt_u32    tbl_min;
  ccentry_t *tbl;
  ktt_u32    tbl_dbg;
  cctoken_t  tok;
} cclex_t;

typedef struct ccread_t
{
  cclex_t    lex;
  cctoken_t *buf;
  cctoken_t *max;
  cctoken_t *min;
  cctoken_t *bed;
} ccread_t;

typedef struct cctype_t
{ cctypekind_t kind;

  const char *name;

  int size;
  int align;

  union
  { cctype_t *ret;
    cctype_t *arr;
    cctype_t *ptr;
    cctype_t *modifier_of;
  };

  struct cctree_t *list;

  int bitoff;
  int bitlen;

  unsigned    is_unsigned: 1;
  unsigned    is_static:   1;
  unsigned    is_variadic: 1;
} cctype_t;

typedef struct cctree_t
{
  cctreetype_t kind;

  unsigned is_variadic: 1;
  unsigned is_abstract: 1;
  unsigned is_constant: 1;

  ccstr_t   label_name;
  ccstr_t    decl_name;
  cctree_t  *init_tree;
  cctree_t  *cond_tree;
  cctree_t  *then_tree;
  cctree_t  *else_tree;
  cctree_t  *expr_tree;
  cctree_t  *body_tree;
  cctree_t  *args_tree;
  cctree_t  *stmt_list;
  cctype_t  *decl_type;
  cctree_t  *decl_size;
  cctree_t  *decl_init;
  cctree_t  *decl_list;

  union
  { struct
    { cctype_t * type;
      cctoken_t  token;
    } constant;
    struct
    { cctoken_t   token;
      cctree_t  * expr; // <-- either a const expression or an identifier.
      cctree_t  * next; // <-- part of the designator list.
    } designator;
    struct
    { cctree_t  * list;
      cctree_t  * init;
      cctree_t  * next; // <-- if part of an initializer list.
    } designation;
    struct
    { cctoken_t   opr;
      cctree_t  * lhs;
      cctree_t  * mhs;
      cctree_t  * rhs;
    } top;
    struct
    { cctoken_t   opr;
      cctree_t  * lhs;
      cctree_t  * rhs;
    } binary;
    struct
    { cctoken_t   opr;
      cctree_t  * mhs;
    } uop;
  };
} cctree_t;

typedef enum ccedict_K ccedict_K;
typedef enum ccvalue_K ccvalue_K;
typedef struct ccemit_value_t ccemit_value_t;
typedef struct ccexec_value_t ccexec_value_t;
typedef struct ccedict_t ccedict_t;
typedef struct ccblock_t ccblock_t;
typedef struct ccfunction_t ccfunction_t;

typedef enum ccedict_K
{
	ccedict_kSTORE = 0,
  ccedict_kLOCAL,
  ccedict_kLOAD,

  ccedict_kBINARY,
  ccedict_Kblock,
  ccedict_Kcondi,
  ccedict_kENTER,
  ccedict_Kleave,
  ccedict_Kcall,
  ccedict_Kreturn,
} ccedict_K;

// Note: boil this down to a function, constant value or instruction, local value, global value
typedef enum ccvalue_K
{ ccvalue_Kinvalid=0,
  ccvalue_Kblock,
  ccvalue_kCONST,
  ccvalue_kGLOBAL,
  ccvalue_kFUNC,
  ccvalue_kEDICT,
} ccvalue_K;

// Todo: boil this down to either a constant value or an instruction ...
typedef struct ccemit_value_t
{
	ccvalue_K kind;

	// Todo: remove the name
  ccstr_t   name;

	struct
	{ cctype_t   * type;
		ccclassic_t  clsc;
	} constant;
  ccfunction_t *function;
  ccedict_t    *edict;
  ccblock_t    *block;
} ccemit_value_t;

typedef struct ccedict_t
{ ccedict_K   kind;
	struct
	{
		cctype_t   *type;
		const char *debug_label;
	} local;
	struct
	{ ccedict_t      *adr;
		ccemit_value_t *val;
	} store;
	struct
	{ ccedict_t *adr; // Note: the instruction that loaded the memory ...
	} load;
	struct
	{ ccemit_value_t * cnd;
  	ccblock_t      * then_blc;
  	ccblock_t      * else_blc;
	} condi;
	struct
	{ ccblock_t      * blc;
	} enter;
	struct
	{ cctoken_k        opr;
	  ccemit_value_t * lhs;
	  ccemit_value_t * rhs;
	} binary;
} ccedict_t;

typedef struct ccexec_value_t
{ const char *debug_label;

	cctype_t     *type;

  ccclassic_t   clsc;
  void         *addr;

  unsigned      is_const: 		  1;
  unsigned      is_edict_value: 1;
} ccexec_value_t;

typedef struct ccblock_t
{ const char  *debug_label;

	ccemit_value_t    result_value;

  ccblock_t   *super;
  ccemit_value_t   *local;
  ccedict_t   *instr;
} ccblock_t;

typedef struct ccfunction_t
{ const char  *debug_label;
	cctype_t    *type;
	ccblock_t   *block;
	ccblock_t   *decls;
	ccblock_t   *enter;
  ccblock_t   *leave;
} ccfunction_t;

typedef struct ccemit_t
{ ccemit_value_t    *globals;
  ccblock_t    *current;
  int           curirix;
} ccemit_t;

typedef struct ccexec_t
{ ccemit_t       *emit;
	ccexec_value_t *values;
  ccfunction_t   *routine;
  ccblock_t      *current;
  int             curirix;
} ccexec_t;


// TODO(RJ): make this legit!
#ifndef ccsynerr
#ifdef _DEBUG
# define ccsynerr(tok,cod,fmt, ...) cctraceerr(fmt, __VA_ARGS__), ccbreak()
#else
# define ccsynerr(tok,cod,fmt, ...) cctraceerr(fmt, __VA_ARGS__)
#endif
#endif
#ifndef ccsynwar
# define ccsynwar(tok,cod,fmt, ...) cctracewar(fmt, __VA_ARGS__)
#endif


ccfunc ccstr_t
cctree_idenname(cctree_t *name)
{
  return name?name->constant.token.str:0;
}

ccfunc void
cclex_init(cclex_t *l);

ccfunc void
cclex_move(cclex_t *l, size_t len, const char *bed);

ccfunc ktt_i32
cclex_next_token(cclex_t *l);

ccfunc void
cclex_token(cclex_t *l, cctoken_t *token);

ccfunc void
cclex_uninit(cclex_t *l);

ccfunc cctoken_t *
ccpeep(ccread_t *parser);

ccfunc ktt_i32
ccsee(ccread_t *parser, cctoken_k kind);

ccfunc cctoken_t *
ccgobble(ccread_t *parser);

ccfunc cctree_t *
ccread_decl_name(ccread_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_declarator(ccread_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_decl_name_list(ccread_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_init_decl(ccread_t *parser);

ccfunc cctree_t * // <-- returns null when the base_type is null
ccread_struct_declarator(ccread_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_struct_declarator_list(ccread_t *parser, cctype_t *base_type);

ccfunc cctree_t *
ccread_struct_declaration(ccread_t *parser);

ccfunc cctree_t *
ccread_struct_declaration_list(ccread_t *parser);

ccfunc ktt_i32
ccread_attribute_seq(ccread_t *parser);

ccfunc cctype_t *
ccread_declaration_specifiers(ccread_t *parser);

ccfunc cctype_t *
ccread_specifier_qualifier_list(ccread_t *parser);

ccfunc cctree_t *
ccread_assignment_expr(ccread_t *parser);

ccfunc cctree_t *
ccread_expression(ccread_t *parser);

ccfunc cctree_t *
ccread_cast_expr(ccread_t *parser);

ccfunc cctree_t *
ccread_declname(ccread_t *parser, cctype_t *base_type);

ccfunc void
cctype_del(cctype_t *type);

ccfunc cctype_t *
cctype_new(cctypekind_t kind, const char *name);

ccfunc cctype_t *
cctype_clone(cctype_t *type);

ccfunc cctype_t *
cctype_new_ptr(cctype_t *modifier_of);

ccfunc cctype_t *
cctype_new_arr(cctype_t *modifier_of);

ccfunc cctype_t *
cctype_new_fun(cctype_t *modifier_of, cctree_t *);

ccfunc void
cctree_del(cctree_t *tree);

ccfunc cctree_t *
cctree_new(cctreetype_t kind);

ccfunc cctree_t *
cctree_new_constant(cctype_t *type, cctoken_t *token);

ccfunc cctree_t *
cctree_new_top(cctoken_t *token, cctree_t *lhs, cctree_t *mhs, cctree_t *rhs);

ccfunc cctree_t *
cctree_binary(cctoken_t *token, cctree_t *lhs, cctree_t *rhs);

ccfunc cctree_t *
cctree_new_uop(cctoken_t *token, cctree_t *mhs);

ccfunc cctree_t *
cctree_new_designator(cctoken_t *token, cctree_t *expr);

ccfunc cctree_t *
cctree_new_designation(cctree_t *list, cctree_t *init);

ccfunc cctree_t *
cctree_new_init_declarator(cctree_t *decl, cctree_t *init);

ccfunc cctree_t *
cctree_new_init_declaration(cctype_t *type, cctree_t *list);

ccfunc cctree_t *
cctree_new_identifier(cctoken_t *token);

// TEMPORARY:
ccglobal cctype_t
  *ctype_flo32  = cctype_new(cctype_float32,"keitt::f32"),
  *ctype_flo64  = cctype_new(cctype_float64,"keitt::f64"),
  *ctype_int64  = cctype_new(cctype_int64,"keitt::i64"),
  *ctype_int32  = cctype_new(cctype_int32,"keitt::i32"),
  *ctype_int16  = cctype_new(cctype_int16,"keitt::i16"),
  *ctype_int8   = cctype_new(cctype_int8,"keitt::i8"),
  *ctype_uint64 = cctype_new(cctype_uint64,"keitt::u64"),
  *ctype_uint32 = cctype_new(cctype_uint32,"keitt::u32"),
  *ctype_uint16 = cctype_new(cctype_uint16,"keitt::u16"),
  *ctype_uint8  = cctype_new(cctype_uint8,"keitt::u8"),
  *ctype_void   = cctype_new(cctype_void,"keitt::void");


ccfunc void
ccread_init(ccread_t *parser)
{ memset(parser, 0, sizeof(*parser));
  cclex_init(& parser->lex);
  parser->bed = 0;
  parser->min = 0;
  parser->max = 0;
}

ccfunc void
ccread_uninit(ccread_t *parser)
{ cclex_uninit(& parser->lex); // <-- free all the string memory.
  ccarrdel(parser->buf); // <-- free all the buffered tokens.
}

ccfunc void
ccread_all_tokens(ccread_t *parser);

// Todo: reset the token array ...
ccfunc void
ccreader_move(ccread_t *parser, size_t len, const char *min)
{
	cclex_move(& parser->lex, len, min);
  ccread_all_tokens(parser);

  parser->bed = 0;
  parser->min = parser->buf;
  parser->max = parser->buf + ccarrlen(parser->buf);
}

ccfunc void
ccread_include(ccread_t *reader, const char *name)
{
  unsigned long int size;
  void *file=ccopenfile(name);
  void *data=ccpullfile(file,0,&(size=0));
  ccclosefile(file);

  ccreader_move(reader,size,(char*)data);

  // Todo:
  // ccfree(data);
}

ccfunc void
ccread_all_tokens(ccread_t *parser)
{ while(cclex_next_token(& parser->lex))
  {
    cctoken_t *token=ccarradd(parser->buf,1);
    cclex_token(& parser->lex,token);
  }
}

ccfunc cctoken_t *
kttc__peek_ahead(ccread_t *parser, ktt_i32 offset)
{ if((parser->min + offset < parser->max))
  { return parser->min + offset;
  }
  // TODO(RJ): this should point to a valid location in a file?
  static cctoken_t end_tok = { cctoken_Kend }; // <-- hopefully no-one modifies this.
  return & end_tok;
}

ccfunc cctoken_t *
ccpeep(ccread_t *parser)
{ return kttc__peek_ahead(parser, 0);
}

ccfunc ktt_i32
ccsee(ccread_t *parser, cctoken_k kind)
{ return ccpeep(parser)->bit == kind;
}

ccfunc ktt_i32
ccsee_end(ccread_t *parser)
{ return ccsee(parser, cctoken_Kend);
}

ccfunc ktt_i32
kttc__peek_oper_increment(ccread_t *parser)
{
  cctoken_t *tok0 = kttc__peek_ahead(parser, 0);
  cctoken_t *tok1 = kttc__peek_ahead(parser, 1);
  return (tok0->sig == cctoken_Kadd) && (tok1->sig == cctoken_Kadd);
}

ccfunc ktt_i32
kttc__peek_oper_decrement(ccread_t *parser)
{
  cctoken_t *tok0 = kttc__peek_ahead(parser, 0);
  cctoken_t *tok1 = kttc__peek_ahead(parser, 1);
  return (tok0->sig == cctoken_Ksub) &&  (tok1->sig == cctoken_Ksub);
}

ccfunc cctoken_t *
kttc__consume_oper_increment(ccread_t *parser, cctoken_k new_sig)
{
  if(kttc__peek_oper_increment(parser))
  { cctoken_t *tok = ccgobble(parser);
    tok->sig = new_sig;
    ccgobble(parser);
    return tok;
  }

  return ccnil;
}

ccfunc cctoken_t *
kttc__consume_oper_decrement(ccread_t *parser, cctoken_k new_sig)
{
  if(kttc__peek_oper_decrement(parser))
  { cctoken_t *tok = ccgobble(parser);
    tok->sig = new_sig;
    ccgobble(parser);
    return tok;
  }

  return ccnil;
}

ccfunc cctoken_t *
kttc__peek_alignment_specifier(ccread_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > kttc__algn_spec_0 &&
     token->bit < kttc__algn_spec_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
kttc__peek_type_qualifier(ccread_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > cctype_qual_0 &&
     token->bit < cctype_qual_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
ccsee_typespec(ccread_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > cctype_spec_0 &&
     token->bit < cctype_spec_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
kttc__peek_storage_class(ccread_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > kttc__scls_spec_0 &&
     token->bit < kttc__scls_spec_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
kttc__peek_func_specifier(ccread_t *parser)
{
  cctoken_t *token = ccpeep(parser);

  if(token->bit > kttc__func_spec_0 &&
     token->bit < kttc__func_spec_1)
  {
    return token;
  }
  return ccnil;
}

ccfunc cctoken_t *
ccgobble(ccread_t *reader)
{ if((reader->min<reader->max)) return reader->bed = reader->min ++;
  return ccpeep(reader); // <-- use peek here to return special end token.
}

// NOTE(RJ): gotta be careful with how you inline this in a function call, order of execution my not be what you'd
// expect, especially if one of the arguments is recursive.
ccfunc cctoken_t *
cceat(ccread_t *parser, cctoken_k kind)
{ if(ccsee(parser,kind)) return ccgobble(parser);
  return 0;
}


ccfunc cctype_t *
cctype_new(cctypekind_t kind, const char *name)
{ cctype_t *result=(cctype_t *)ccmalloc(sizeof(cctype_t));
  memset(result,0,sizeof(*result));

  result->kind=kind;
  result->name=name;
  return result;
}

ccfunc cctree_t *
cctree_new(cctreetype_t kind)
{ cctree_t *result = (cctree_t *) ccmalloc(sizeof(cctree_t));
  memset(result, 0, sizeof(*result));
  result->kind = kind;
  return result;
}

ccfunc void
cctype_del(cctype_t *type)
{ ccfree(type);
}

ccfunc void
cctree_del(cctree_t *tree)
{ ccfree(tree);
}

ccfunc cctype_t *
cctype_clone(cctype_t *type)
{ cctype_t *result=cctype_new(type->kind,0);
  *result=*type;
  return result;
}

ccfunc cctype_t *
cctype_new_ptr(cctype_t *modifier_of)
{ cctype_t *type = cctype_new(cctype_ptr,"ptr");
  type->modifier_of = modifier_of;
  return type;
}

ccfunc cctype_t *
cctype_new_arr(cctype_t *modifier_of)
{ cctype_t *type = cctype_new(cctype_arr,"arr");
  type->modifier_of = modifier_of;
  return type;
}

ccfunc cctype_t *
cctype_new_fun(cctype_t *modifier_of, cctree_t *list)
{ cctype_t *type = cctype_new(cctype_Kfunc,"fun");
  type->modifier_of=modifier_of;
  type->list=list;
  return type;
}

ccfunc cctype_t *
cctype_new_struct_spec(cctree_t *list, cctree_t *name)
{ ccassert(list!=0);
  cctype_t *type=cctype_new(cctype_struct_spec,cctree_idenname(name));
  type->list=list;
  return type;
}

ccfunc cctree_t *
cctree_decl_name(cctype_t *type, cctree_t *name, cctree_t *size, cctree_t *init)
{ cctree_t *tree = cctree_new(cctree_Kdecl_name);
  tree->decl_type=type;
  tree->decl_name=cctree_idenname(name);
  tree->decl_size=size;
  tree->decl_init=init;
  return tree;
}

ccfunc cctree_t *
cctree_decl(cctype_t *type, cctree_t *list)
{ cctree_t *tree = cctree_new(cctree_kDECL);
  tree->decl_type=type;
  tree->decl_list=list;
  return tree;
}

ccfunc cctree_t *
cctree_new_designator(cctoken_t *token, cctree_t *expr)
{ cctree_t *tree = cctree_new(cctree_t_designator);
  tree->designator.token = * token;
  tree->designator.expr  = expr;
  return tree;
}

ccfunc cctree_t *
cctree_new_constant(cctype_t *type, cctoken_t *token)
{ cctree_t *result = cctree_new(cctree_kINTEGER);
  result->constant.type  = type;
  result->constant.token = *token;
  return result;
}

ccfunc cctree_t *
cctree_new_top(cctoken_t *token, cctree_t *lhs, cctree_t *mhs, cctree_t *rhs)
{ cctree_t *result = cctree_new(cctree_kBINARY);
  result->top.opr = * token;
  result->top.lhs = lhs;
  result->top.mhs = mhs;
  result->top.rhs = rhs;
  return result;
}

ccfunc cctree_t *
cctree_binary(cctoken_t *token, cctree_t *lhs, cctree_t *rhs)
{ cctree_t *result = cctree_new(cctree_kBINARY);
  result->binary.opr = * token;
  result->binary.lhs = lhs;
  result->binary.rhs = rhs;
  return result;
}

ccfunc cctree_t *
cctree_new_uop(cctoken_t *token, cctree_t *mhs)
{ cctree_t *result = cctree_new(cctree_t_uop);
  result->uop.opr = * token;
  result->uop.mhs = mhs;
  return result;
}


ccfunc cctree_t *
cctree_new_identifier(cctoken_t *token)
{ // Make sure we return null here, not just for safety but because other functions
  // depend on it for convenience.
  if(token)
  {
    cctree_t *tree = cctree_new(cctree_kIDENTIFIER);
    tree->constant.token = * token;
    return tree;
  }
  return ccnil;
}

#if 0
ccfunc cctree_t *
cctree_new_struct_decl_name(cctree_t *decl, cctree_t *expr)
{ ccassert(decl!=0);
  cctree_t *tree = cctree_new(cctree_Kstruct_decl_name);
  tree->struct_decl_name.decl = decl;
  tree->struct_decl_name.expr = expr;
  return tree;
}
ccfunc cctree_t *
cctree_new_struct_decl(cctype_t *type, cctree_t *list)
{ ccassert(type!=0);
  ccassert(list!=0);
  cctree_t *tree = cctree_new(cctree_Kstruct_decl);
  tree->struct_decl.type = type;
  tree->struct_decl.list = list;
  return tree;
}
#endif

ccfunc cctree_t *
cctree_new_designation(cctree_t *list, cctree_t *init)
{ // Make sure we return null here, not just for safety but because other functions
  // depend on it for convenience.
  if(list)
  {
    cctree_t *tree = cctree_new(cctree_t_designation);
    tree->designation.list = list;
    tree->designation.init = init;
    return tree;
  }
  return ccnil;
}

#endif